// Javascript for the Groove Scribe HTML application
// Groove Scribe is for drummers and helps create sheet music with an easy to use WYSIWYG groove editor.
//
// Author: Lou Montulli
// Original Creation date: Feb 2015.
//
//  Copyright 2015-2020 Lou Montulli, Mike Johnston
//
//  This file is part of Project Groove Scribe.
//
//  Groove Scribe is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 2 of the License, or
//  (at your option) any later version.
//
//  Groove Scribe is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with Groove Scribe.  If not, see <http://www.gnu.org/licenses/>.

// GrooveWriter class.   The only one in this file.

/*jslint browser:true devel:true */
/*global Abc, MIDI, Midi */

var global_num_GrooveUtilsCreated = 0;
var global_midiInitialized = false;



// GrooveUtils class.   The only one in this file.
function GrooveUtils() {
	"use strict";

	global_num_GrooveUtilsCreated++; // should increment on every new

	var root = this;

	root.abc_obj = null;

	// local constants
	var CONSTANT_Midi_play_time_zero = "0:00";

	// array that can be used to map notes to the SVG generated by abc2svg
	root.note_mapping_array = null;

	// debug & special view
	root.debugMode = false;
	root.viewMode = true;  // by default to prevent screen flicker
	root.grooveDBAuthoring = false;

	// midi state variables
	root.isMIDIPaused = false;
	root.shouldMIDIRepeat = true;
	root.swingIsEnabled = false;
	root.grooveUtilsUniqueIndex = global_num_GrooveUtilsCreated;

	// metronome options
	// root.metronomeSolo = false;
	// root.metronomeOffsetClickStart = "1";
	// start with last in the rotation so the next rotation brings it to '1'
	// root.metronomeOffsetClickStartRotation = 0;

	root.isLegendVisable = false;

	// integration with third party components
	root.noteCallback = null;  //function triggered when a note is played
	root.playEventCallback = null;  //triggered when the play button is pressed
	root.repeatCallback = null;  //triggered when a groove is going to be repeated
	root.tempoChangeCallback = null;  //triggered when the tempo changes.  ARG1 is the new Tempo integer (needs to be very fast, it can get called a lot of times from the slider)

	var class_empty_note_array = [false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false];

	root.visible_context_menu = false; // a single context menu can be visible at a time.

	root.grooveDataNew = function () {
		this.notesPerMeasure = 16;
		this.timeDivision = 16;
		this.numberOfMeasures = 1;
		this.numBeats = 4;  // TimeSigTop: Top part of Time Signture 3/4, 4/4, 5/4, 6/8, etc...
		this.noteValue = 4; // TimeSigBottom: Bottom part of Time Sig   4 = quarter notes, 8 = 8th notes, 16ths, etc..
		this.sticking_array = class_empty_note_array.slice(0); // copy by value
		this.hh_array = class_empty_note_array.slice(0);    // copy by value
		this.snare_array = class_empty_note_array.slice(0); // copy by value
		this.kick_array = class_empty_note_array.slice(0);  // copy by value
		// toms_array contains 4 toms  T1, T2, T3, T4 index starting at zero
		this.toms_array = [class_empty_note_array.slice(0), class_empty_note_array.slice(0), class_empty_note_array.slice(0), class_empty_note_array.slice(0)];
		this.showToms = false;
		this.showStickings = false;
		this.title = "";
		this.author = "";
		this.comments = "";
		this.showLegend = false;
		this.swingPercent = 0;
		this.tempo = constant_DEFAULT_TEMPO;
		this.kickStemsUp = true;
		this.metronomeFrequency = 0; // 0, 4, 8, 16
		this.debugMode = root.debugMode;
		this.grooveDBAuthoring = root.grooveDBAuthoring;
		this.viewMode = root.viewMode;
		this.repeatedMeasures = new Map();
		this.highlightOn = true;
	};

	root.myGrooveData = root.grooveDataNew();




	

	

	

	

	

	
	// callback class for abc generator library
	function SVGLibCallback() {
		// -- required methods
		this.abc_svg_output = "";
		this.abc_error_output = "";

		// include a file (%%abc-include)
		this.read_file = function (fn) {
			return "";
		};
		// insert the errors
		this.errmsg = function (msg, l, c) {
			this.abc_error_output += msg + "<br/>\n";
		};

		// for possible playback or linkage
		this.get_abcmodel = function (tsfirst, voice_tb, music_types) {

			/*
			console.log(tsfirst);
			var next = tsfirst.next;

			while(next) {
			console.log(next);
			next = next.next;
			}
			 */
		};

		// annotations
		this.anno_start = function (type, start, stop, x, y, w, h) { };
		this.svg_highlight_y = 0;
		this.svg_highlight_h = 44;
		this.anno_stop = function (type, start, stop, x, y, w, h) {

			// create a rectangle
			if (type == "bar") {
				// use the bar as the default y & hack
				this.svg_highlight_y = y + 5;
				this.svg_highlight_h = h + 10;
			}
			if (type == "note" || type == "grace") {
				y = this.svg_highlight_y;
				h = this.svg_highlight_h;
				root.abc_obj.out_svg('<rect style="fill: transparent;" class="abcr" id="abcNoteNum_' + root.grooveUtilsUniqueIndex + "_" + root.abcNoteNumIndex + '" x="');
				root.abc_obj.out_sxsy(x, '" y="', y);
				root.abc_obj.out_svg('" width="' + w.toFixed(2) + '" height="' + h.toFixed(2) + '"/>\n');

				//console.log("Type:"+type+ "\t abcNoteNumIndex:"+root.abcNoteNumIndex+ "\t X:"+x+ "\t Y:"+y+ "\t W:"+w+ "\t H:"+h);

				// don't increment on the grace note, since it is attached to the real note
				if (type != "grace")
					root.abcNoteNumIndex++;
			}
		};

		// image output
		this.img_out = function (str) {
			this.abc_svg_output += str; // + '\n'
		};

		// -- optional attributes
		this.page_format = true; // define the non-page-breakable blocks
	}
	var abcToSVGCallback = new SVGLibCallback(); // singleton


	// converts incoming ABC notation source into an svg image.
	// returns an object with two items.   "svg" and "error_html"
	root.renderABCtoSVG = function (abc_source) {
		root.abc_obj = new Abc(abcToSVGCallback);
		if ((root.myGrooveData && root.myGrooveData.showLegend) || root.isLegendVisable)
			root.abcNoteNumIndex = -15; // subtract out the legend notes for a proper index.
		else
			root.abcNoteNumIndex = 0;
		abcToSVGCallback.abc_svg_output = ''; // clear
		abcToSVGCallback.abc_error_output = ''; // clear

		root.abc_obj.tosvg("SOURCE", abc_source);
		return {
			svg: abcToSVGCallback.abc_svg_output,
			error_html: abcToSVGCallback.abc_error_output
		};
	};



	

	

	// ******************************************************************************************************************
	// ******************************************************************************************************************
	//
	// MIDI functions
	//
	// ******************************************************************************************************************
	// ******************************************************************************************************************
	

	root.midiEventCallbackClass = function (classRoot) {
		this.classRoot = classRoot;
		this.noteHasChangedSinceLastDataLoad = false;

		this.playEvent = function (root) {
			var icon = document.getElementById("midiPlayImage" + root.grooveUtilsUniqueIndex);
			if (icon)
				icon.className = "midiPlayImage Playing";
			if (root.playEventCallback) {
				root.playEventCallback();
			}
		};
		// default loadMIDIDataEvent.  You probably want to override this
		// it will only make changes to the tempo and swing
		// playStarting: boolean that is true on the first time through the midi playback
		this.loadMidiDataEvent = function (root, playStarting) {
			if (root.myGrooveData) {
				root.myGrooveData.tempo = root.getTempo();
				root.myGrooveData.swingPercent = root.getSwing();
				var midiURL = root.create_MIDIURLFromGrooveData(root.myGrooveData);
				root.loadMIDIFromURL(midiURL);
				root.midiEventCallbacks.noteHasChangedSinceLastDataLoad = false;
			} else {
				console.log("can't load midi song.   myGrooveData is empty");
			}
		};
		this.doesMidiDataNeedRefresh = function (root) {
			return root.midiEventCallbacks.noteHasChangedSinceLastDataLoad;
		};
		this.pauseEvent = function (root) {
			var icon = document.getElementById("midiPlayImage" + root.grooveUtilsUniqueIndex);
			if (icon)
				icon.className = "midiPlayImage Paused";
		};

		this.resumeEvent = function (root) { };
		this.stopEvent = function (root) {
			var icon = document.getElementById("midiPlayImage" + root.grooveUtilsUniqueIndex);
			if (icon)
				icon.className = "midiPlayImage Stopped";
		};
		this.repeatChangeEvent = function (root, newValue) {
			if (newValue)
				document.getElementById("midiRepeatImage" + root.grooveUtilsUniqueIndex).src = getMidiImageLocation() + "repeat.png";
			else
				document.getElementById("midiRepeatImage" + root.grooveUtilsUniqueIndex).src = getMidiImageLocation() + "grey_repeat.png";
		};
		this.percentProgress = function (root, percent) { };
		this.notePlaying = function (root, note_type, note_position) { };

		this.midiInitialized = function (root) {
			var icon = document.getElementById("midiPlayImage" + root.grooveUtilsUniqueIndex);
			if (icon)
				icon.className = "midiPlayImage Stopped";
			document.getElementById("midiPlayImage" + root.grooveUtilsUniqueIndex).onclick = function (event) {
				root.startOrStopMIDI_playback();
			}; // enable play button
			setupHotKeys(root); // spacebar to play
		};
	};
	root.midiEventCallbacks = new root.midiEventCallbackClass(root);

	// set a URL for midi playback.
	// useful for static content, so you don't have to override the loadMidiDataEvent callback
	root.setGrooveData = function (grooveData) {
		root.myGrooveData = grooveData;
	};

	// This is called so that the MIDI player will reload the groove
	// at repeat time.   If not set then the midi player just repeats what is already loaded.
	root.midiNoteHasChanged = function () {
		root.midiEventCallbacks.noteHasChangedSinceLastDataLoad = true;
	};
	root.midiResetNoteHasChanged = function () {
		root.midiEventCallbacks.noteHasChangedSinceLastDataLoad = false;
	};

	
	/*
	 * midi_output_type:  "general_MIDI" or "Custom"
	 * num_notes: number of notes in the arrays  (currently expecting 32 notes per measure)
	 * metronome_frequency: 0, 4, 8, 16   None, quarter notes, 8th notes, 16ths
	 * num_notes_for_swing: how many notes are we using.   Since we need to know where the upstrokes are we need to know
	 *                      what the proper division is.   It can change when we are doing permutations, otherwise it is what is the
	 *                      class_notes_per_measure
	 *
	 * The arrays passed in contain the ABC notation for a given note value or false for a rest.
	 */
	root.MIDI_from_HH_Snare_Kick_Arrays = function (midiTrack, HH_Array, Snare_Array, Kick_Array, Toms_Array, midi_output_type, metronome_frequency, num_notes, num_notes_for_swing, swing_percentage, timeSigTop, timeSigBottom) {
		var prev_metronome_note = false;
		var prev_hh_note = 46;  // default to open hi-hat so that the first hi-hat note also mutes any previous hh open.
		var prev_snare_note = false;
		var prev_kick_note = false;
		var prev_kick_splash_note = false;
		var midi_channel = 9;  // percussion

		if (swing_percentage < 0 || swing_percentage > 0.99) {
			console.log("Swing percentage out of range in GrooveUtils.MIDI_from_HH_Snare_Kick_Arrays");
			swing_percentage = 0;
		}

		// start of midi track
		// Some sort of bug in the midi player makes it skip the first note without a blank
		// TODO: Find and fix midi bug
		if (midiTrack.events.length < 4) {
			midiTrack.addNoteOff(midi_channel, 60, 1); // add a blank note for spacing
		}

		var isTriplets = isTripletDivisionFromNotesPerMeasure(num_notes, timeSigTop, timeSigBottom);
		var offsetClickStartBeat = getMetronomeOptionsOffsetClickStartRotation(isTriplets);
		var delay_for_next_note = 0;

		for (var i = 0; i < num_notes; i++) {

			var duration = 0;

			if (isTriplets) {
				duration = 10.666; // "ticks"   16 for 32nd notes.  10.66 for 48th triplets
			} else {
				duration = 16;
			}

			if (swing_percentage !== 0) {
				// swing effects the note placement of the e and the a.  (1e&a)
				// swing increases the distance between the 1 and the e ad shortens the distance between the e and the &
				// likewise the distance between the & and the a is increased and the a and the 1 is shortened
				//  So it sounds like this:   1-e&-a2-e&-a3-e&-a4-e&-a
				var scaler = num_notes / num_notes_for_swing;
				var val = i % (4 * scaler);

				if (val < scaler) {
					// this is the 1, increase the distance between this note and the e
					duration += (duration * swing_percentage);
				} else if (val < scaler * 2) {
					// this is the e, shorten the distance between this note and the &
					duration -= (duration * swing_percentage);
				} else if (val < scaler * 3) {
					// this is the &, increase the distance between this note and the a
					duration += (duration * swing_percentage);
				} else if (val < scaler * 4) {
					// this is the a, shorten the distance between this note and the 2
					duration -= (duration * swing_percentage);
				}
			}

			// Metronome sounds.
			var metronome_note = false;
			var metronome_velocity = constant_OUR_MIDI_VELOCITY_ACCENT;
			if (metronome_frequency > 0) {
				var quarterNoteFrequency = (isTriplets ? 12 : 8);
				var eighthNoteFrequency = (isTriplets ? 6 : 4);
				var sixteenthNoteFrequency = (isTriplets ? 2 : 2);

				var metronome_specific_index = i;
				switch (offsetClickStartBeat) {
					case "1":
						// default do nothing
						break;
					case "E":
						if (isTriplets)
							console.log("OffsetClickStart error in MIDI_from_HH_Snare_Kick_Arrays");
						// shift by one sixteenth note
						metronome_specific_index -= sixteenthNoteFrequency;
						break;
					case "AND":
						if (isTriplets)
							console.log("OffsetClickStart error in MIDI_from_HH_Snare_Kick_Arrays");
						// shift by two sixteenth notes
						metronome_specific_index -= (2 * sixteenthNoteFrequency);
						break;
					case "A":
						if (isTriplets)
							console.log("OffsetClickStart error in MIDI_from_HH_Snare_Kick_Arrays");
						// shift by three sixteenth notes
						metronome_specific_index -= (3 * sixteenthNoteFrequency);
						break;
					case "TI":
						if (!isTriplets)
							console.log("OffsetClickStart error in MIDI_from_HH_Snare_Kick_Arrays");
						// shift by one sixteenth note
						metronome_specific_index -= sixteenthNoteFrequency * 2;
						break;
					case "TA":
						if (!isTriplets)
							console.log("OffsetClickStart error in MIDI_from_HH_Snare_Kick_Arrays");
						// shift by two sixteenth notes
						metronome_specific_index -= (2 * (sixteenthNoteFrequency * 2));
						break;
					default:
						console.log("bad case in MIDI_from_HH_Snare_Kick_Arrays");
						break;
				}

				if (metronome_specific_index >= 0) { // can go negative due to MetronomeOffsetClickStart shift above
					// Special sound on the one
					if (metronome_specific_index === 0 || (metronome_specific_index % (quarterNoteFrequency * timeSigTop * (4 / timeSigBottom))) === 0) {
						metronome_note = constant_OUR_MIDI_METRONOME_1; // 1 count

					} else if ((metronome_specific_index % quarterNoteFrequency) === 0) {
						metronome_note = constant_OUR_MIDI_METRONOME_NORMAL; // standard metronome click
					}

					if (!metronome_note && metronome_frequency == 8) { // 8th notes requested
						if ((metronome_specific_index % eighthNoteFrequency) === 0) {
							// click every 8th note
							metronome_note = constant_OUR_MIDI_METRONOME_NORMAL; // standard metronome click
						}

					} else if (!metronome_note && metronome_frequency == 16) { // 16th notes requested
						if ((metronome_specific_index % sixteenthNoteFrequency) === 0) {
							// click every 16th note
							metronome_note = constant_OUR_MIDI_METRONOME_NORMAL; // standard metronome click
							metronome_velocity = 25; // not as loud as the normal click
						}
					}
				}

				if (metronome_note !== false) {
					//if(prev_metronome_note != false)
					//	midiTrack.addNoteOff(midi_channel, prev_metronome_note, 0);
					midiTrack.addNoteOn(midi_channel, metronome_note, delay_for_next_note, metronome_velocity);
					delay_for_next_note = 0; // zero the delay
					//prev_metronome_note = metronome_note;
				}
			}

			if (!root.metronomeSolo) { // midiSolo means to play just the metronome
				var hh_velocity = constant_OUR_MIDI_VELOCITY_NORMAL;
				var hh_note = false;
				switch (HH_Array[i]) {
					case constant_ABC_HH_Normal: // normal
					case constant_ABC_HH_Close: // normal
						hh_note = constant_OUR_MIDI_HIHAT_NORMAL;
						break;
					case constant_ABC_HH_Accent: // accent
						if (midi_output_type == "general_MIDI") {
							hh_note = constant_OUR_MIDI_HIHAT_NORMAL;
							hh_velocity = constant_OUR_MIDI_VELOCITY_ACCENT;
						} else {
							hh_note = constant_OUR_MIDI_HIHAT_ACCENT;
						}
						break;
					case constant_ABC_HH_Open: // open
						hh_note = constant_OUR_MIDI_HIHAT_OPEN;
						break;
					case constant_ABC_HH_Ride: // ride
						hh_note = constant_OUR_MIDI_HIHAT_RIDE;
						break;
					case constant_ABC_HH_Ride_Bell: // ride bell
						hh_note = constant_OUR_MIDI_HIHAT_RIDE_BELL;
						break;
					case constant_ABC_HH_Cow_Bell: // cow bell
						hh_note = constant_OUR_MIDI_HIHAT_COW_BELL;
						break;
					case constant_ABC_HH_Crash: // crash
						hh_note = constant_OUR_MIDI_HIHAT_CRASH;
						break;
					case constant_ABC_HH_Stacker: // stacker
						hh_note = constant_OUR_MIDI_HIHAT_STACKER;
						break;
					case constant_ABC_HH_Metronome_Normal: // Metronome beep
						hh_note = constant_OUR_MIDI_HIHAT_METRONOME_NORMAL;
						break;
					case constant_ABC_HH_Metronome_Accent: // Metronome beep
						hh_note = constant_OUR_MIDI_HIHAT_METRONOME_ACCENT;
						break;
					case false:
						break;
					default:
						console.log("Bad case in GrooveUtils.MIDI_from_HH_Snare_Kick_Arrays");
						break;
				}

				if (hh_note !== false) {
					// need to end hi-hat open notes else the hh open sounds horrible
					if (prev_hh_note !== false) {
						midiTrack.addNoteOff(midi_channel, prev_hh_note, delay_for_next_note);
						prev_hh_note = false;
						delay_for_next_note = 0; // zero the delay
					}
					midiTrack.addNoteOn(midi_channel, hh_note, delay_for_next_note, hh_velocity);
					delay_for_next_note = 0; // zero the delay

					// this if means that only the open hi-hat will get stopped on the next note
					if (HH_Array[i] == constant_ABC_HH_Open)
						prev_hh_note = hh_note;
				}

				var snare_velocity = constant_OUR_MIDI_VELOCITY_NORMAL;
				var snare_note = false;
				switch (Snare_Array[i]) {
					case constant_ABC_SN_Normal: // normal
						snare_note = constant_OUR_MIDI_SNARE_NORMAL;
						break;
					case constant_ABC_SN_Flam: // flam
						if (midi_output_type == "general_MIDI") {
							snare_note = constant_OUR_MIDI_SNARE_NORMAL;
							snare_velocity = constant_OUR_MIDI_VELOCITY_ACCENT;
						} else {
							snare_note = constant_OUR_MIDI_SNARE_FLAM;
							snare_velocity = constant_OUR_MIDI_VELOCITY_NORMAL;
						}
						break;
					case constant_ABC_SN_Drag: // drag
						if (midi_output_type == "general_MIDI") {
							snare_note = constant_OUR_MIDI_SNARE_NORMAL;
							snare_velocity = constant_OUR_MIDI_VELOCITY_ACCENT;
						} else {
							snare_note = constant_OUR_MIDI_SNARE_DRAG;
							snare_velocity = constant_OUR_MIDI_VELOCITY_NORMAL;
						}
						break;
					case constant_ABC_SN_Accent: // accent
						if (midi_output_type == "general_MIDI") {
							snare_note = constant_OUR_MIDI_SNARE_NORMAL;
							snare_velocity = constant_OUR_MIDI_VELOCITY_ACCENT;
						} else {
							snare_note = constant_OUR_MIDI_SNARE_ACCENT; // custom note
						}
						break;
					case constant_ABC_SN_Ghost: // ghost
						if (midi_output_type == "general_MIDI") {
							snare_note = constant_OUR_MIDI_SNARE_NORMAL;
							snare_velocity = constant_OUR_MIDI_VELOCITY_GHOST;
						} else {
							snare_note = constant_OUR_MIDI_SNARE_GHOST;
							snare_velocity = constant_OUR_MIDI_VELOCITY_GHOST;
						}
						break;
					case constant_ABC_SN_XStick: // xstick
						snare_note = constant_OUR_MIDI_SNARE_XSTICK;
						break;
					case constant_ABC_SN_Buzz: // xstick
						snare_note = constant_OUR_MIDI_SNARE_BUZZ;
						break;
					case false:
						break;
					default:
						console.log("Bad case in GrooveUtils.MIDI_from_HH_Snare_Kick_Arrays");
						break;
				}

				if (snare_note !== false) {
					//if(prev_snare_note != false)
					//	midiTrack.addNoteOff(midi_channel, prev_snare_note, 0);
					midiTrack.addNoteOn(midi_channel, snare_note, delay_for_next_note, snare_velocity);
					delay_for_next_note = 0; // zero the delay
					//prev_snare_note = snare_note;
				}

				var kick_note = false;
				var kick_splash_note = false;
				switch (Kick_Array[i]) {
					case constant_ABC_KI_Splash: // just HH Foot
						kick_splash_note = constant_OUR_MIDI_HIHAT_FOOT;
						break;
					case constant_ABC_KI_SandK: // Kick & HH Foot
						kick_splash_note = constant_OUR_MIDI_HIHAT_FOOT;
						kick_note = constant_OUR_MIDI_KICK_NORMAL;
						break;
					case constant_ABC_KI_Normal: // just Kick
						kick_note = constant_OUR_MIDI_KICK_NORMAL;
						break;
					case false:
						break;
					default:
						console.log("Bad case in GrooveUtils.MIDI_from_HH_Snare_Kick_Arrays");
						break;
				}
				if (kick_note !== false) {
					//if(prev_kick_note != false)
					//	midiTrack.addNoteOff(midi_channel, prev_kick_note, 0);
					midiTrack.addNoteOn(midi_channel, kick_note, delay_for_next_note, constant_OUR_MIDI_VELOCITY_NORMAL);
					delay_for_next_note = 0; // zero the delay
					//prev_kick_note = kick_note;
				}
				if (kick_splash_note !== false) {
					if (prev_hh_note !== false) {
						midiTrack.addNoteOff(midi_channel, prev_hh_note, delay_for_next_note);
						prev_hh_note = false;
						delay_for_next_note = 0; // zero the delay
					}
					//if(prev_kick_splash_note != false)
					//	midiTrack.addNoteOff(midi_channel, prev_kick_splash_note, 0);
					midiTrack.addNoteOn(midi_channel, kick_splash_note, delay_for_next_note, constant_OUR_MIDI_VELOCITY_NORMAL);
					delay_for_next_note = 0; // zero the delay
					//prev_kick_splash_note = kick_splash_note;
				}

				if (Toms_Array) {
					for (var which_array = 0; which_array < constant_NUMBER_OF_TOMS; which_array++) {
						var tom_note = false;
						if (Toms_Array[which_array][i] !== undefined) {
							switch (Toms_Array[which_array][i]) {
								case constant_ABC_T1_Normal: // Tom 1
									tom_note = constant_OUR_MIDI_TOM1_NORMAL;  // midi code High tom 2
									break;
								case constant_ABC_T2_Normal: // Midi code Mid tom 1
									tom_note = constant_OUR_MIDI_TOM2_NORMAL;
									break;
								case constant_ABC_T3_Normal: // Midi code Mid tom 2
									tom_note = constant_OUR_MIDI_TOM3_NORMAL;
									break;
								case constant_ABC_T4_Normal: // Midi code Low Tom 1
									tom_note = constant_OUR_MIDI_TOM4_NORMAL;
									break;
								case false:
									break;
								default:
									console.log("Bad case in GrooveUtils.MIDI_from_HH_Snare_Kick_Arrays");
									break;
							}
						}
						if (tom_note !== false) {
							midiTrack.addNoteOn(midi_channel, tom_note, delay_for_next_note, constant_OUR_MIDI_VELOCITY_NORMAL);
							delay_for_next_note = 0; // zero the delay
						}
					}
				}

			} // end metronomeSolo

			delay_for_next_note += duration;
		}

		if (delay_for_next_note)
			midiTrack.addNoteOff(0, 60, delay_for_next_note - 1); // add a blank note for spacing

	}; // end of function

	// returns a URL that is a MIDI track
	root.create_MIDIURLFromGrooveData = function (myGrooveData, MIDI_type) {

		var midiFile = new Midi.File();
		var midiTrack = new Midi.Track();
		midiFile.addTrack(midiTrack);

		midiTrack.setTempo(myGrooveData.tempo);
		midiTrack.setInstrument(0, 0x13);

		var swing_percentage = myGrooveData.swingPercent / 100;

		// the midi converter expects all the arrays to be 32 or 48 notes long.
		// Expand them
		var FullNoteHHArray = scaleNoteArrayToFullSize(myGrooveData.hh_array, myGrooveData.numberOfMeasures, myGrooveData.notesPerMeasure, myGrooveData.numBeats, myGrooveData.noteValue);
		var FullNoteSnareArray = scaleNoteArrayToFullSize(myGrooveData.snare_array, myGrooveData.numberOfMeasures, myGrooveData.notesPerMeasure, myGrooveData.numBeats, myGrooveData.noteValue);
		var FullNoteKickArray = scaleNoteArrayToFullSize(myGrooveData.kick_array, myGrooveData.numberOfMeasures, myGrooveData.notesPerMeasure, myGrooveData.numBeats, myGrooveData.noteValue);

		// the midi functions expect just one measure at a time to work correctly
		// call once for each measure
		var measure_notes = FullNoteHHArray.length / myGrooveData.numberOfMeasures;
		for (var measureIndex = 0; measureIndex < myGrooveData.numberOfMeasures; measureIndex++) {

			var FullNoteTomsArray = [];
			for (var i = 0; i < constant_NUMBER_OF_TOMS; i++) {
				var orig_measure_notes = myGrooveData.notesPerMeasure;
				FullNoteTomsArray[i] = scaleNoteArrayToFullSize(myGrooveData.toms_array[i].slice(orig_measure_notes * measureIndex, orig_measure_notes * (measureIndex + 1)),
					1,
					myGrooveData.notesPerMeasure,
					myGrooveData.numBeats,
					myGrooveData.noteValue);
			}

			root.MIDI_from_HH_Snare_Kick_Arrays(midiTrack,
				FullNoteHHArray.slice(measure_notes * measureIndex, measure_notes * (measureIndex + 1)),
				FullNoteSnareArray.slice(measure_notes * measureIndex, measure_notes * (measureIndex + 1)),
				FullNoteKickArray.slice(measure_notes * measureIndex, measure_notes * (measureIndex + 1)),
				FullNoteTomsArray,
				MIDI_type,
				myGrooveData.metronomeFrequency,
				measure_notes,
				myGrooveData.timeDivision,
				swing_percentage,
				myGrooveData.numBeats,
				myGrooveData.noteValue);
		}

		var midi_url = "data:audio/midi;base64," + btoa(midiFile.toBytes());

		return midi_url;
	};

	root.loadMIDIFromURL = function (midiURL) {

		MIDI.Player.timeWarp = 1; // speed the song is played back
		MIDI.Player.BPM = root.getTempo();
		MIDI.Player.loadFile(midiURL, midiLoaderCallback());
	};

	root.MIDISaveAs = function (midiURL) {

		// save as
		document.location = midiURL;
	};

	root.pauseMIDI_playback = function () {
		if (root.isMIDIPaused === false) {
			root.isMIDIPaused = true;
			root.midiEventCallbacks.pauseEvent(root.midiEventCallbacks.classRoot);
			MIDI.Player.pause();
			root.midiEventCallbacks.notePlaying(root.midiEventCallbacks.classRoot, "clear", -1);
			clearHighlightNoteInABCSVG(root.grooveUtilsUniqueIndex);
		}
	};

	// play button or keypress
	root.startMIDI_playback = function () {
		if (MIDI.Player.playing) {
			return;
		} else if (root.isMIDIPaused && false === root.midiEventCallbacks.doesMidiDataNeedRefresh(root.midiEventCallbacks.classRoot)) {
			global_current_midi_start_time = new Date();
			global_last_midi_update_time = 0;
			MIDI.Player.resume();
		} else {
			MIDI.Player.ctx.resume();
			global_current_midi_start_time = new Date();
			global_last_midi_update_time = 0;
			root.midiEventCallbacks.loadMidiDataEvent(root.midiEventCallbacks.classRoot, true);
			MIDI.Player.stop();
			MIDI.Player.loop(root.shouldMIDIRepeat); // set the loop parameter
			MIDI.Player.start();
		}
		root.midiEventCallbacks.playEvent(root.midiEventCallbacks.classRoot);
		root.isMIDIPaused = false;
	};

	// stop button or keypress
	root.stopMIDI_playback = function () {
		if (MIDI.Player.playing || root.isMIDIPaused) {
			root.isMIDIPaused = false;
			MIDI.Player.stop();
			root.midiEventCallbacks.stopEvent(root.midiEventCallbacks.classRoot);
			root.midiEventCallbacks.notePlaying(root.midiEventCallbacks.classRoot, "clear", -1);
			clearHighlightNoteInABCSVG(root.grooveUtilsUniqueIndex);
			resetMetronomeOptionsOffsetClickStartRotation()
		}
	};

	// modal play/stop button
	root.startOrStopMIDI_playback = function () {

		if (MIDI.Player.playing) {
			root.stopMIDI_playback();
		} else {
			root.startMIDI_playback();
		}
	};

	// modal play/pause button
	root.startOrPauseMIDI_playback = function () {

		if (MIDI.Player.playing) {
			root.pauseMIDI_playback();
		} else {
			root.startMIDI_playback();
		}
	};

	root.isPlaying = function () {
		return MIDI.Player.playing;
	};

	root.repeatMIDI_playback = function () {
		if (root.shouldMIDIRepeat === false) {
			root.shouldMIDIRepeat = true;
			MIDI.Player.loop(true);
		} else {
			root.shouldMIDIRepeat = false;
			MIDI.Player.loop(false);
		}
		root.midiEventCallbacks.repeatChangeEvent(root.midiEventCallbacks.classRoot, root.shouldMIDIRepeat);

	};

	root.oneTimeInitializeMidi = function () {

		if (global_midiInitialized) {
			root.midiEventCallbacks.midiInitialized(root.midiEventCallbacks.classRoot);
			return;
		}

		global_midiInitialized = true;
		MIDI.loadPlugin({
			soundfontUrl: getMidiSoundFontLocation(),
			instruments: ["gunshot"],
			callback: function () {
				MIDI.programChange(9, 127); // use "Gunshot" instrument because I don't know how to create new ones
				root.midiEventCallbacks.midiInitialized(root.midiEventCallbacks.classRoot);
			}
		});
	};

	root.getMidiStartTime = function () {
		return global_current_midi_start_time;
	};

	// calculate how long the midi has been playing total (since the last play/pause press
	// this is computationally expensive
	root.getMidiPlayTime = function () {
		var time_now = new Date();
		var play_time_diff = new Date(time_now.getTime() - global_current_midi_start_time.getTime());

		var TotalPlayTime = document.getElementById("totalPlayTime");
		if (TotalPlayTime) {
			if (global_last_midi_update_time === 0)
				global_last_midi_update_time = global_current_midi_start_time;
			var delta_time_diff = new Date(time_now - global_last_midi_update_time);
			global_total_midi_play_time_msecs += delta_time_diff.getTime();
			var totalTime = new Date(global_total_midi_play_time_msecs);
			var time_string = "";
			if (totalTime.getUTCHours() > 0)
				time_string = totalTime.getUTCHours() + ":" + (totalTime.getUTCMinutes() < 10 ? "0" : "");
			time_string += totalTime.getUTCMinutes() + ":" + (totalTime.getSeconds() < 10 ? "0" : "") + totalTime.getSeconds();
			TotalPlayTime.innerHTML = 'Total Play Time: <span class="totalTimeNum">' + time_string + '</span> notes: <span class="totalTimeNum">' + global_total_midi_notes + '</span> repetitions: <span class="totalTimeNum">' + global_total_midi_repeats + '</span>';
		}

		global_last_midi_update_time = time_now;

		return play_time_diff; // a time struct that represents the total time played so far since the last play button push
	};

	// update the midi play timer on the player.
	// Keeps track of how long we have been playing.
	root.updateMidiPlayTime = function () {
		var totalTime = root.getMidiPlayTime();
		var time_string = totalTime.getUTCMinutes() + ":" + (totalTime.getSeconds() < 10 ? "0" : "") + totalTime.getSeconds();

		var MidiPlayTime = document.getElementById("MIDIPlayTime" + root.grooveUtilsUniqueIndex);
		if (MidiPlayTime)
			MidiPlayTime.innerHTML = time_string;
	};

	var debug_note_count = 0;
	//var class_midi_note_num = 0;  // global, but only used in this function
	// This is the function that the 3rd party midi library calls to give us events.
	// This is different from the callbacks that we use for the midi code in this library to
	// do events.   (Double chaining)
	function ourMIDICallback(data) {
		var percentComplete = (data.now / data.end);
		root.midiEventCallbacks.percentProgress(root.midiEventCallbacks.classRoot, percentComplete * 100);

		if (root.lastMidiTimeUpdate && root.lastMidiTimeUpdate < (data.now + 800)) {
			root.updateMidiPlayTime();
			root.lastMidiTimeUpdate = data.now;
		}

		if (data.now < 16) {
			// this is considered the start.   It doesn't come in at zero for some reason
			// The second note should always be at least 16 ms behind the first
			//class_midi_note_num = 0;
			root.lastMidiTimeUpdate = -1;
		}
		if (data.now == data.end) {

			// at the end of a song
			root.midiEventCallbacks.notePlaying(root.midiEventCallbacks.classRoot, "complete", 1);

			if (root.shouldMIDIRepeat) {

				global_total_midi_repeats++;

				// regenerate the MIDI if the data needs refreshing or the OffsetClick is rotating every time
				// advanceMetronomeOptionsOffsetClickStartRotation will return false if not rotating
				if (advanceMetronomeOptionsOffsetClickStartRotation() || root.midiEventCallbacks.doesMidiDataNeedRefresh(root.midiEventCallbacks.classRoot)) {
					MIDI.Player.stop();
					root.midiEventCallbacks.loadMidiDataEvent(root.midiEventCallbacks.classRoot, false);
					MIDI.Player.start();
					//  } else {
					// let midi.loop handle the repeat for us
					//MIDI.Player.stop();
					//MIDI.Player.start();
				}
				if (root.repeatCallback) {
					root.repeatCallback();
				}
			} else {
				// not repeating, so stopping
				MIDI.Player.stop();
				root.midiEventCallbacks.percentProgress(root.midiEventCallbacks.classRoot, 100);
				root.midiEventCallbacks.stopEvent(root.midiEventCallbacks.classRoot);
			}
		}

		// note on
		var note_type = false;
		if (data.message == 144) {
			if (data.note == constant_OUR_MIDI_METRONOME_1 || data.note == constant_OUR_MIDI_METRONOME_NORMAL) {
				note_type = "metronome";
			} else if (data.note == constant_OUR_MIDI_HIHAT_NORMAL || data.note == constant_OUR_MIDI_HIHAT_OPEN ||
				data.note == constant_OUR_MIDI_HIHAT_ACCENT || data.note == constant_OUR_MIDI_HIHAT_CRASH ||
				data.note == constant_OUR_MIDI_HIHAT_RIDE || data.note == constant_OUR_MIDI_HIHAT_STACKER ||
				data.note == constant_OUR_MIDI_HIHAT_RIDE_BELL || data.note == constant_OUR_MIDI_HIHAT_COW_BELL ||
				data.note == constant_OUR_MIDI_HIHAT_METRONOME_NORMAL || data.note == constant_OUR_MIDI_HIHAT_METRONOME_NORMAL) {
				note_type = "hi-hat";
			} else if (data.note == constant_OUR_MIDI_SNARE_NORMAL || data.note == constant_OUR_MIDI_SNARE_ACCENT ||
				data.note == constant_OUR_MIDI_SNARE_GHOST || data.note == constant_OUR_MIDI_SNARE_XSTICK ||
				data.note == constant_OUR_MIDI_SNARE_FLAM || data.note == constant_OUR_MIDI_SNARE_DRAG ||
				data.note == constant_OUR_MIDI_SNARE_BUZZ) {
				note_type = "snare";
			} else if (data.note == constant_OUR_MIDI_KICK_NORMAL || data.note == constant_OUR_MIDI_HIHAT_FOOT) {
				note_type = "kick";
			} else if (data.note == constant_OUR_MIDI_TOM1_NORMAL || data.note == constant_OUR_MIDI_TOM2_NORMAL || data.note == constant_OUR_MIDI_TOM3_NORMAL || data.note == constant_OUR_MIDI_TOM4_NORMAL) {
				note_type = "tom";
			}
			if (note_type) {
				global_total_midi_notes++;
				root.midiEventCallbacks.notePlaying(root.midiEventCallbacks.classRoot, note_type, percentComplete);
				if (root.highlightOn) highlightNoteInABCSVGFromPercentComplete(root.grooveUtilsUniqueIndex, root.note_mapping_array, percentComplete, root.numberOfMeasures, root.repeatedMeasures);
				if (root.noteCallback) {
					root.noteCallback(note_type);
				}
			}
		}

		// this used to work when we used note 60 as a spacer between chords
		//if(data.note == 60)
		//	class_midi_note_num++;
		/*
		if (0 && data.message == 144) {
		debug_note_count++;
		// my debugging code for midi
		var newHTML = "";
		if (data.note != 60)
		newHTML += "<b>";

		newHTML += note_type + " total notes: " + debug_note_count + " - count#: " + class_midi_note_num +
		" now: " + data.now +
		" note: " + data.note +
		" message: " + data.message +
		" channel: " + data.channel +
		" velocity: " + data.velocity +
		"<br>";

		if (data.note != 60)
		newHTML += "</b>";

		document.getElementById("midiTextOutput").innerHTML += newHTML;
		}
		 */
	}

	function midiLoaderCallback() {
		MIDI.Player.addListener(ourMIDICallback);
	}

	root.getTempo = function () {
		var tempoInput = document.getElementById("tempoInput" + root.grooveUtilsUniqueIndex);
		var tempo = constant_DEFAULT_TEMPO;

		if (tempoInput) {
			tempo = parseInt(tempoInput.value, 10);
			if (tempo < 19 && tempo > 281)
				tempo = constant_DEFAULT_TEMPO;
		}

		return tempo;
	};

	// we need code to make the range slider colors update properly
	function updateRangeSlider(sliderID) {

		var slider = document.getElementById(sliderID);
		var programaticCSSRules = document.getElementById(sliderID + "CSSRules");
		if (!programaticCSSRules) {
			// create a new one.
			programaticCSSRules = document.createElement('style');
			programaticCSSRules.id = sliderID + "CSSRules";
			document.body.appendChild(programaticCSSRules);
		}

		var style_before = document.defaultView.getComputedStyle(slider, ":before");
		var style_after = document.defaultView.getComputedStyle(slider, ":after");
		var before_color = style_before.getPropertyValue('color');
		var after_color = style_after.getPropertyValue('color');

		// change the before and after colors of the slider using a gradiant
		var percent = Math.ceil(((slider.value - slider.min) / (slider.max - slider.min)) * 100);

		var new_style_str = '#' + sliderID + '::-moz-range-track' + '{ background: -moz-linear-gradient(left, ' + before_color + ' ' + percent + '%, ' + after_color + ' ' + percent + '%)}\n';
		new_style_str += '#' + sliderID + '::-webkit-slider-runnable-track' + '{ background: -webkit-linear-gradient(left, ' + before_color + ' ' + '0%, ' + before_color + ' ' + percent + '%, ' + after_color + ' ' + percent + '%)}\n';
		programaticCSSRules.textContent = new_style_str;

	}

	// update the tempo string display
	// called by the oninput handler everytime the range slider changes
	root.tempoUpdate = function (tempo) {
		document.getElementById('tempoTextField' + root.grooveUtilsUniqueIndex).value = "" + tempo;

		updateRangeSlider('tempoInput' + root.grooveUtilsUniqueIndex);
		root.midiNoteHasChanged();

		if (root.tempoChangeCallback)
			root.tempoChangeCallback(tempo);
	};

	root.tempoUpdateFromTextField = function (event) {
		var newTempo = event.target.value;

		document.getElementById("tempoInput" + root.grooveUtilsUniqueIndex).value = newTempo;
		root.tempoUpdate(newTempo);
	};

	// update the tempo string display
	root.tempoUpdateFromSlider = function (event) {
		root.tempoUpdate(event.target.value);
	};

	// I love the pun here.  :)
	// nudge the tempo up by 1
	root.upTempo = function () {
		var tempo = root.getTempo();

		tempo++;

		root.setTempo(tempo);
	};

	// nudge the tempo down by 1
	root.downTempo = function () {
		var tempo = root.getTempo();

		tempo--;

		root.setTempo(tempo);
	};

	root.setTempo = function (newTempo) {
		if (newTempo < 19 && newTempo > 281)
			return;

		document.getElementById("tempoInput" + root.grooveUtilsUniqueIndex).value = newTempo;
		root.tempoUpdate(newTempo);
	};

	root.doesDivisionSupportSwing = function (division) {

		if (isTripletDivision(division) || division == 4)
			return false;

		return true;
	};

	root.setSwingSlider = function (newSetting) {
		document.getElementById("swingInput" + root.grooveUtilsUniqueIndex).value = newSetting;
		updateRangeSlider('swingInput' + root.grooveUtilsUniqueIndex);
	};

	root.swingEnabled = function (trueElseFalse) {

		root.swingIsEnabled = trueElseFalse;

		if (root.swingIsEnabled === false) {
			root.setSwing(0);
		} else {
			root.swingUpdateText(root.getSwing()); // remove N/A label
		}
	};

	root.getSwing = function () {
		var swing = 0;

		if (root.swingIsEnabled) {
			var swingInput = document.getElementById("swingInput" + root.grooveUtilsUniqueIndex);

			if (swingInput) {
				swing = parseInt(swingInput.value, 10);
				if (swing < 0 || swing > 60)
					swing = 0;
			}
		}

		return (swing);
	};

	// used to update the on screen swing display
	// also the onClick handler for the swing slider
	root.swingUpdateText = function (swingAmount) {

		if (root.swingIsEnabled === false) {
			document.getElementById('swingOutput' + root.grooveUtilsUniqueIndex).innerHTML = "N/A";
		} else {
			document.getElementById('swingOutput' + root.grooveUtilsUniqueIndex).innerHTML = "" + swingAmount + "%";
			root.swingPercent = swingAmount;
			root.midiNoteHasChanged();
		}

	};

	root.setSwing = function (swingAmount) {
		if (root.swingIsEnabled === false)
			swingAmount = 0;

		root.setSwingSlider(swingAmount);

		root.swingUpdateText(swingAmount);  // update the output
	};

	root.swingUpdateEvent = function (event) {

		if (root.swingIsEnabled === false) {
			root.setSwingSlider(0);
		} else {
			root.swingUpdateText(event.target.value);
			updateRangeSlider('swingInput' + root.grooveUtilsUniqueIndex);
		}
	};

	root.setMetronomeFrequencyDisplay = function (newFrequency) {
		var mm = document.getElementById('midiMetronomeMenu' + root.grooveUtilsUniqueIndex);

		if (mm) {
			mm.className = mm.className.replace(" selected", "");

			if (newFrequency > 0) {
				mm.className += " selected";
			}
		}
	};

	// open a new tab with GrooveScribe with the current groove
	root.loadFullScreenGrooveScribe = function () {
		var fullURL = getUrlStringFromGrooveData(root.myGrooveData, 'fullGrooveScribe')

		var win = window.open(fullURL, '_blank');
		win.focus();
	};


	// turn the metronome on and off
	root.metronomeMiniMenuClick = function () {
		if (root.myGrooveData.metronomeFrequency > 0)
			root.myGrooveData.metronomeFrequency = 0;
		else
			root.myGrooveData.metronomeFrequency = 4;

		root.setMetronomeFrequencyDisplay(root.myGrooveData.metronomeFrequency);
		root.midiNoteHasChanged();
	};

	root.expandOrRetractMIDI_playback = function (force, expandElseContract) {

		var playerControlElement = document.getElementById('playerControl' + root.grooveUtilsUniqueIndex);
		var playerControlRowElement = document.getElementById('playerControlsRow' + root.grooveUtilsUniqueIndex);
		var tempoAndProgressElement = document.getElementById('tempoAndProgress' + root.grooveUtilsUniqueIndex);
		var midiMetronomeMenuElement = document.getElementById('midiMetronomeMenu' + root.grooveUtilsUniqueIndex);
		var gsLogoLoadFullGSElement = document.getElementById('midiGSLogo' + root.grooveUtilsUniqueIndex);
		var midiExpandImageElement = document.getElementById('midiExpandImage' + root.grooveUtilsUniqueIndex);
		var midiPlayTime = document.getElementById('MIDIPlayTime' + root.grooveUtilsUniqueIndex);

		if (playerControlElement.className.indexOf("small") > -1 || (force && expandElseContract)) {
			// make large
			playerControlElement.className = playerControlElement.className.replace(" small", "") + " large";
			playerControlRowElement.className = playerControlRowElement.className.replace(" small", "") + " large";
			tempoAndProgressElement.className = tempoAndProgressElement.className.replace(" small", "") + " large";
			midiMetronomeMenuElement.className = midiMetronomeMenuElement.className.replace(" small", "") + " large";
			gsLogoLoadFullGSElement.className = gsLogoLoadFullGSElement.className.replace(" small", "") + " large";
			midiExpandImageElement.className = midiExpandImageElement.className.replace(" small", "") + " large";
			midiPlayTime.className = midiPlayTime.className.replace(" small", "") + " large";
		} else {
			// make small
			playerControlElement.className = playerControlElement.className.replace(" large", "") + " small";
			playerControlRowElement.className = playerControlRowElement.className.replace(" large", "") + " small";
			midiMetronomeMenuElement.className = midiMetronomeMenuElement.className.replace(" large", "") + " small";
			tempoAndProgressElement.className = tempoAndProgressElement.className.replace(" large", "") + " small";
			gsLogoLoadFullGSElement.className = gsLogoLoadFullGSElement.className.replace(" large", "") + " small";
			midiExpandImageElement.className = midiExpandImageElement.className.replace(" large", "") + " small";
			midiPlayTime.className = midiPlayTime.className.replace(" large", "") + " small";
		}

	};





	root.HTMLForMidiPlayer = function (expandable) {
		var newHTML = '' +
			'<div id="playerControl' + root.grooveUtilsUniqueIndex + '" class="playerControl">' +
			'	<div class="playerControlsRow" id="playerControlsRow' + root.grooveUtilsUniqueIndex + '">' +
			'		<span title="Play/Pause" class="midiPlayImage" id="midiPlayImage' + root.grooveUtilsUniqueIndex + '"></span>' +
			'       <span class="MIDIPlayTime" id="MIDIPlayTime' + root.grooveUtilsUniqueIndex + '">' + CONSTANT_Midi_play_time_zero + '</span>';

		if (expandable)
			newHTML += '' +
				'       <span title="Metronome controls" class="midiMetronomeMenu" id="midiMetronomeMenu' + root.grooveUtilsUniqueIndex + '">' +
				addInlineMetronomeSVG() +
				'       </span>'


		newHTML += '<span class="tempoAndProgress" id="tempoAndProgress' + root.grooveUtilsUniqueIndex + '">' +
			'			<div class="tempoRow">' +
			'				<span class="tempoLabel">BPM</span>' +
			'				<input type="text" for="tempo" class="tempoTextField" pattern="\\d+" id="tempoTextField' + root.grooveUtilsUniqueIndex + '" value="80"></input>' +
			'				<input type=range min=30 max=300 value=90 class="tempoInput' + (is_touch_device() ? ' touch' : '') + '" id="tempoInput' + root.grooveUtilsUniqueIndex + '" list="tempoSettings">' +
			'			</div>' +
			'			<div class="swingRow">' +
			'				<span class="swingLabel">SWING</span>' +
			'				<span for="swingAmount" class="swingOutput" id="swingOutput' + root.grooveUtilsUniqueIndex + '">0% swing</span>' +
			'				<input type=range min=0 max=50 value=0 class="swingInput' + (is_touch_device() ? ' touch' : '') + '" id="swingInput' + root.grooveUtilsUniqueIndex + '" list="swingSettings" step=5 >' +
			'			</div>' +
			'       </span>';

		if (expandable)
			newHTML +=
				'       <span title="Expand full screen in GrooveScribe" class="midiGSLogo" id="midiGSLogo' + root.grooveUtilsUniqueIndex + '">' +
				addInLineGScribeLogoLoneGSVG() +
				'       </span>' +
				'		<span title="Expand/Retract player" class="midiExpandImage" id="midiExpandImage' + root.grooveUtilsUniqueIndex + '"></span>';

		newHTML += '</div>';

		return newHTML;
	};

	// pass in a tag ID.  (not a class)
	// HTML will be put within the tag replacing whatever else was there
	root.AddMidiPlayerToPage = function (HTML_Id_to_attach_to, division, expandable) {
		var html_element = document.getElementById(HTML_Id_to_attach_to);
		if (html_element)
			html_element.innerHTML = root.HTMLForMidiPlayer(expandable);

		var browserInfo = getBrowserInfo();
		var isIE10 = false;
		if (browserInfo.browser == "MSIE" && browserInfo.version < 12)
			isIE10 = true;

		// now attach the onclicks
		html_element = document.getElementById("tempoInput" + root.grooveUtilsUniqueIndex);
		if (html_element) {
			if (isIE10)
				html_element.addEventListener("click", root.tempoUpdateFromSlider, false);
			else
				html_element.addEventListener("input", root.tempoUpdateFromSlider, false);
		}

		html_element = document.getElementById("tempoTextField" + root.grooveUtilsUniqueIndex);
		if (html_element) {
			html_element.addEventListener("change", root.tempoUpdateFromTextField, false);
		}

		html_element = document.getElementById("swingInput" + root.grooveUtilsUniqueIndex);
		if (html_element) {
			if (isIE10)
				html_element.addEventListener("click", root.swingUpdateEvent, false);
			else
				html_element.addEventListener("input", root.swingUpdateEvent, false);
		}

		html_element = document.getElementById("midiRepeatImage" + root.grooveUtilsUniqueIndex);
		if (html_element) {
			html_element.addEventListener("click", root.repeatMIDI_playback, false);
		}

		html_element = document.getElementById("midiExpandImage" + root.grooveUtilsUniqueIndex);
		if (html_element) {
			html_element.addEventListener("click", root.expandOrRetractMIDI_playback, false);
		}

		html_element = document.getElementById("midiGSLogo" + root.grooveUtilsUniqueIndex);
		if (html_element) {
			html_element.addEventListener("click", root.loadFullScreenGrooveScribe, false);
		}

		html_element = document.getElementById("midiMetronomeMenu" + root.grooveUtilsUniqueIndex);
		if (html_element) {
			html_element.addEventListener("click", root.metronomeMiniMenuClick, false);
		}

		// enable or disable swing
		root.swingEnabled(root.doesDivisionSupportSwing(division));
	};

} // end of class
